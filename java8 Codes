===============================================
  	/*
					 * InterfaceName refvar=(par1,pr2)->{
					 *   
					 *   
					 *   };
					 */
		Comparator<Employee> comparator1=(emp1,emp2)->{
			return emp1.getAge()-emp2.getAge();
		};
		
		List<Employee> el=EmployeeService.getEmployees();
		Collections.sort(el, comparator1);
		
		for(Employee ele:el) {
			System.out.println(ele);
		}
========================================================

/*
	 * Consumer -> accept(T) ->no return Type
	 * BiCosumer ->accept(T,U) ->no return Type
	 * 
	 * Predicate ->Boolean Test(T) ->returns boolean
	 * BiPredicate->Booelan Test(T,U) ->return boolean
	 * 
	 * Supplier ->T get()->returns T Type
	 * 
	 * Function  ->  R apply(T) ->returns R
	 * BiFunction -> R apply(T,U) ->return R
	 */
	
	
	
	public static void main(String[] args){
					
		Consumer<String> c1=(name)->{
			System.out.println("Hi :"+name);
		};
		
		BiConsumer<Integer,Integer>c2=(n1,n2)->{
			System.out.println(n1+n2);
		};
		
		Consumer<String> c3=(name)->{
			System.out.println("Bye :"+name);
		};
		c1.accept("Rahul");
		c2.accept(12,8);
		
		
		Predicate<Integer> p1=(n)->n>100;
		
		BiPredicate<Integer,Integer> p2=(n1,n2)->n1>n2;
		
		System.out.println(p1.test(101));
		System.out.println(p2.test(12, 3));
		
		
		Supplier<Integer> s1=()->{ return 2;};
		System.out.println(s1.get());
		
		
		c1.andThen(c3).andThen(c3).accept("virat");
		
		Function<Integer,Integer> f1=(n)->n*n;
		
		BiFunction<Integer,Integer,Integer> f2=(n1,n2)->n1*n2;
		
		System.out.println(f1.apply(12));
		System.out.println(f2.apply(3, 8));

===================================================================
List<Integer> l1=Arrays.asList(12,3,4,5,7,11,89);
		
		List<Employee> el=EmployeeService.getEmployees();
		
		Predicate<Integer> p1=(age)->age>30;
	
//		l1.forEach(ele->{
//			System.out.println(ele+11);
//			System.out.println("hi");
//		});
		
		
		el.forEach(ele->
		{
			System.out.println(ele.getName()+"---"+ele.getAge()+"---"+ele.getSalary());
			if(p1.test(ele.getAge())) {
				ele.setSalary(ele.getSalary()+5000);
			}
			System.out.println(ele.getName()+"---"+ele.getAge()+"---"+ele.getSalary());
			System.out.println("==================================================");
		});
/*
	 * Terminal -> forEach ,sum,average,min,max,count
	 * interediate ->filter,map,sorted 
	 */
	
	public static void main(String[] args){
		
		//Arrays 
		
		int[] arr= {12,3,4,6,8,11};
		
//		Arrays.stream(arr).forEach(ele->System.out.print(ele+" "));
//		
//		System.out.println("========================");
//		Arrays.stream(arr).forEach(ele->{
//			if(ele%2==0) {
//				System.out.println(ele);
//			}
//		});
//		
//		System.out.println("=====================================");
//		Arrays.stream(arr).filter(ele->ele%2==0).forEach(ele->System.out.println(ele));
//		
//		Arrays.stream(arr).parallel().forEach(ele->System.out.println(Thread.currentThread().getName()+"-"+ele));
//		System.out.println("============================================================");
//		Arrays.stream(arr).forEach(ele->System.out.println(Thread.currentThread().getName()+"-"+ele));
//		
	// Sum,Avg,Max,Min.
//		AtomicInteger sum=new AtomicInteger();
//		Arrays.stream(arr).forEach(ele->{
//			sum.addAndGet(ele);
//		});
//		System.out.println(sum);
//		
//		
//		int ans=Arrays.stream(arr).sum();
//		System.out.println(ans);
//		
//		double avg=Arrays.stream(arr).average().orElse(0.0);
//		System.out.println(avg);
//		int min=Arrays.stream(arr).min().orElse(0);
//		int max=Arrays.stream(arr).max().orElse(0);
//		
		
//	// Multiple each number by 7 then print only even ele
//		
//		Arrays.stream(arr).map(ele->ele*7).filter(ele->ele%2==0).forEach(ele->System.out.println(ele));
//		
//		
//	//Count number odd elements in array 
//		long count =Arrays.stream(arr).filter(ele->ele%2==1).count();
//		System.out.println(count);
//		
	//Sort the array
		//Arrays.stream(arr).sorted().forEach(ele->System.out.println(ele));
	// Remove Duplicates
	//	Arrays.stream(arr).distinct().forEach(ele->System.out.println(ele));
	//limit(3) skip(3)
		//skipping two records after sort
		//Arrays.stream(arr).distinct().sorted().skip(2).forEach(ele->System.out.println(ele));
	//second smallest
		int small=Arrays.stream(arr).distinct().sorted().skip(1).findFirst().getAsInt();
	//Thrid smallest
		
	//4,8,9,12,15 
	//2nd largest
		int small=Arrays.stream(arr).distinct().sorted().skip(arr.length-2).findFirst().getAsInt();



		Integer[] arr= {10,20,30,2,5,11,8,17};
		List ans=Arrays.stream(arr).collect(Collectors.toList());
		System.out.println(ans);
		
		Map<Object, Object> m1 = Arrays.stream(arr).collect(Collectors.toMap((ele)->ele, ele->1));
		
		System.out.println(m1);
		
		
//		Map<Object, Object> m2 = Arrays.stream(arr).collect(Collectors.toMap((ele)->ele,ele->1,(u,t)->u,()->new LinkedHashMap<Object, Object>()));
//		
//		System.out.println(m2);
		
		
		//STring [] arr names
		//  apple-5,ball-4
		
		 Map<Object, List<Integer>> m3 = Arrays.stream(arr).collect(Collectors.groupingBy(ele->ele%2==0 ,Collectors.toList()));
		 
		
		System.out.println(m3);
		
		//Group by even length and odd length



public class Employee {

    private int id;
    private String name;
    private Department department;
    private double salary;
    private int age;

    private LocalDate joiningDate;   // <<==== ADDED

    // List of skills
    private List<String> skills;

    // List of projects (nested entity)
    private List<Project> projects;

    // Map of certifications: (CertificationName -> Score)
    private Map<String, Integer> certifications;

    // Address details (key-value)
    private Map<String, String> address;

    public Employee(int id, String name, Department department,
                    double salary, int age,
                    LocalDate joiningDate,          // <<==== ADDED HERE
                    List<String> skills,
                    List<Project> projects,
                    Map<String, Integer> certifications,
                    Map<String, String> address) {

        this.id = id;
        this.name = name;
        this.department = department;
        this.salary = salary;
        this.age = age;
        this.joiningDate = joiningDate;      // <<==== ADDED
        this.skills = skills;
        this.projects = projects;
        this.certifications = certifications;
        this.address = address;
    }

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Department getDepartment() {
		return department;
	}

	public void setDepartment(Department department) {
		this.department = department;
	}

	public double getSalary() {
		return salary;
	}

	public void setSalary(double salary) {
		this.salary = salary;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public LocalDate getJoiningDate() {
		return joiningDate;
	}

	public void setJoiningDate(LocalDate joiningDate) {
		this.joiningDate = joiningDate;
	}

	public List<String> getSkills() {
		return skills;
	}

	public void setSkills(List<String> skills) {
		this.skills = skills;
	}

	public List<Project> getProjects() {
		return projects;
	}

	public void setProjects(List<Project> projects) {
		this.projects = projects;
	}

	public Map<String, Integer> getCertifications() {
		return certifications;
	}

	public void setCertifications(Map<String, Integer> certifications) {
		this.certifications = certifications;
	}

	public Map<String, String> getAddress() {
		return address;
	}

	public void setAddress(Map<String, String> address) {
		this.address = address;
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + ", department=" + department + ", salary=" + salary + ", age="
				+ age + ", joiningDate=" + joiningDate + ", skills=" + skills + ", projects=" + projects
				+ ", certifications=" + certifications + ", address=" + address + "]";
	}

    // getters + setters + toString()
    
    
}

