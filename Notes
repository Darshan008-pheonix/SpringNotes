Spring
Properties:
 ->Spring is the light weighted software which is directly depends on jdk
 ->Spring helps is build loosely coupled application
 ->It Requires less configuration and allows easy integration with any database
 ->It reduces boiler plate codes
 ->It supports IOC where objects are control by the program not by the programmer
 ->It supports dependency injections
 ->It provides default security 

IOC(Inversion Of Control)
 ->Ioc acts like a container in which the control of object creation is given to the program rather than the programmer with the help of 
   configuration file
 ->Ioc helps in creating object implicitly by reading configuration file and instantiate the pojo class

Types Ioc Context or Containers
1)Core Container
  ->We can create core container by using Interface BeanFactory  and XMLBeanFactory implementation class 
  ->We can build only standalone application

2)J2EE Container
  ->We can create this container by using ApplicationContext Interface and its implementation class are
            *ClassPathXmlApplicationContext
            *AnnotationConfigApplicationContext
  ->We can build enterprise level application

3)Web Container
  -> We can create web container by using WebApplicationContext  Interface And its Implementation class is WebApplicationContextUtil

Config.xml
 
Configuration file consists of a parent tag <beans></beans> and child tag is <bean></bean>
In order to configure a pojo class we make use of <bean> tag
<bean> takes two attributes id and class
In id we specify bean id for class we specify fully qualified class name.

Dependency Injection

Dependency Injection (DI) is a design pattern in which objects receive their dependencies from an external source rather than creating them manually by user.
It promotes loose coupling, easier testing, and better code maintainability. In Spring, DI is achieved mainly through Constructor Injection or Setter Injection.

xml data -> https://codeshare.io/5Qgj1e

<property>
    -> this tag will be used inside <bean> tag
    -> this use to set the value for the bean attributes/properties
    -> this tag contains 2 attributes name and value
    name- we need specify the attribute name(var name)
    value- this used specify value(should be encoded in " ")

ex:
<bean id="std" class="com.Student">
 <property name="age" value="28">  </property>
</bean>

class Student{
   
    int age;
    
    void setAge(int age){
       this.age=age;
    }
}

Note:For using property tag setter method for the attribute is must.
it follow proper naming convention

<constructor-arg>
    -> this tag is used inside bean tag when class is having
       parameterized constructor
    ->this tag has a attribute called value
    ->This tag should be used only if there is not at all default 
      construtor otherwise its not compulsory its depends business
      logic.

Ex-
  <bean>
   <constructor-arg value="virat"></constructor-arg>
   <constructor-arg value="28"></constructor-arg>
  </bean>
    
class student{
   
   String name;
   int age;

   Student(String name,int age){
   this.name=name;
   this.age=age;
  }
}

Annotation Based Spring Configuration

@Component:-

* Rather than creating bean tag for every pojo class in .xml configuration file 
  we make use @Component annotation.
* This is the class level annotation used on top of pojo class.
* It is used to make a class as qualified bean for the IOC.

Procedure to achieve annotation based bean creation and access it using .xml
and Application Context
->Create a pojo and annotate as @Component
->Go to .xml file and use <context:component-scan base-package="Package Path"/ > inside <Beans> tag
   Ex:<context:component-scan base-package="com.jspiders"/>
   Note:Make sure <beans> should contain xmlns:context attribute and value
  xml code ->  https://codeshare.io/5QkgDw
->In getBean() please do mention ClassName.class to access the object

@Scope ->Class based annotation
       ->It is used the scope of the class from singleton to prototype etc
      @Scope(value="prototype")

@Value ->It used to perform field injection .It is used inject the values.
         It can been used top of the attributes,Parameters,Setter Method

@Autowired :- It is used achieve automatic dependency injection.
              It will look into the context or container and finds the 
              matching bean and injects inside the field/attribute.
              It can be used with field/attribute ,constructor and setter.

@Primary :- It is class based annotation which describe the bean is having
            higher priority while autowiring .It will bean as default object 
            while autowiring.

@Qualifier :- It is used over come confusion /ambiguity issue when single 
              reference var has multiple objects at the time of autowiring.
              Using @qualifier we can specify the bean which can be autowired.
              @Qualifier can be used attribute/field level also and it 
              can used as class level annotation also.
             @Qualifier should be used along the side of @Autowired
            ex:-@Qualifier("QualifierName/ClassName(CamelCasing))
Note:-Qualifier name can be given for the bean with help @Component or @Qualifier
	
     @Component("QualifierName") 
     #@Qualifier("QualifierName")   
     class Demo{
     }

@Configuration: This annotation marks a class as a source of
bean definitions(creation).This can be used as a alternative
of .xml file.
Any class which is annotated as @Configuration will be treated
as configuration class it is equivalent to the .xml file
We can also use @Bean annotation inside configuration to create bean.

@ComponentScan:-
    This annotation is used along with @Configuration annotation
to search ,scan and create the bean.
Without @Component scan Spring or @Configuration cant search
and create bean automatically
 Syntax:-
      @ComponentScan(BasePackage="path")

MVC(Module View Controller):
   It is design pattern which is used to develop the loosely coupled application
   Model → represents the data & business logic
   View → represents the UI (presentation layer)
   Controller → acts as the request handler / coordinator

Spring MVC:
   It is spring framework which is used develop web application and distributed application.
Spring MVC is a request-driven web framework in the Spring ecosystem that implements the Model–View–Controller pattern on top of the Servlet API.

Spring Components :
->Front Controller(Dispatcher Servlet)
->Handler Mapper
->Controller
->ModelAndView
->ViewResolver
->View 

Front-Controller:-
   It is responsible for performing pre and post processing of incoming request
   Pre-processing :- Capturing the data from the request(ex:-form)
   Post-processing :-Sending response back to client in client understandable form.
  
   ->Spring web mvc application we will use dispatcherservlet as a front controller.
   DispatcherServlet(Spring framework servlet):-Predefine servlet class by spring

Handler Mapper:-
     It is predefine class in spring mvc.It is used to identify the request handler(Controller).The program which is handling the incoming request is called as request
handler.
handler Mapper will identify request handler and returns the details to dispatcher servlet

Controller:-
   It is a program which is used to handle the request.In Spring mvc user can create his own 
controller.In spring MNC some predefined controller classes are available like below
   ->SimpleFormController
   ->AbstractCommandController
   ->MultiActionController etc....
We can create userdefine controller by using @Controller annotation
Controller will return response the MAV or Understandable format 

ModelAndView:
  It is a predefine class in spring mvc.Where Model represent the data and view represent the logical view name.

ViewResolver:
   In spring mvc is multiple view resolver classes+
      ->InternalViewResourceViewResolver
      ->URLBasedViewResolver
      ->XmlViewResolver ...etc
  ->These view resolver are responsible to identify the views and send details(extension and 
    location)

View:
  It is used to render model data to view and returns it

Steps To Creat SpringMvc Project
->Create Maven project with maven-archetype webapp type
->Create configuration class
->create webintializer class with extends AbstractAnnotationConfigDispatcherServletIntilaizer  and override the methods .
->Use webapp for creating jsp pages

Model
An interface used to pass attributes (data) from the controller to
the view.
It acts as a container for the data to be rendered in the view 
(like JSP).
You typically use methods like addAttribute(String key, Object value)
to store data.

ModelMap
A map-based implementation of the Model interface.
It is very similar to Model but gives you direct access 
to the map-like structure(LinkedHashMap).
Useful if you want to add multiple attributes in a more flexible way.

ModelAndView
A holder for both the model and the view.
You can set both the view name and add data to the model
in a single object.
Useful when you want to return both the view and model explicitly.

@Controller:- Its Specialized form of @Component which will mark a 
class as webcontroller .That means this class will work as request
handler  of http request and returs the responses .

@RequestParam:- Its is used in SpringMvc which is used extract
 the data from url parameters,form data or request parameters and 
bind them with method arguements.
Note : Parameters and arguements names should be same

http://localhost:8080/SpringMvcProject/greet?name="Ankur"&&value="Priyanka"       

=================================================================================================================================================================
Monolithic Application
Definition:
A monolithic application is a single-tiered software application in which all the functionalities (UI, business logic, and database access) are packaged and deployed as one unit.

Advantages:
Simple to develop (suitable for beginners or small apps).
Easy to test and debug (everything in one place).
Simple deployment (only one package).
Shared database makes data handling straightforward.

Disadvantages:
Hard to scale (must scale the whole app, not parts).
Slower development for large projects (tight coupling).
Any small change requires redeployment of the entire application.
Failure in one module can bring down the whole system.

Micro Service Application:-
Micro Service is an architecture that allows the developers to develop and deploy services independently. Each service running has its own process and this achieves the lightweight model to support business applications.
Advantages
Micro services offers the following advantages to its developers:
   Easy deployment
   Simple scalability
   Compatible with Containers
   Minimum configuration
   Lesser production time 

What is Spring Boot?
Spring Boot provides a good platform for Java developers to develop a stand-alone and production-grade spring application that you can just run. You can get started with minimum configurations without the need for an entire Spring configuration setup.
Advantages
Spring Boot offers the following advantages to its developers:
   Easy to understand and develop spring applications
   Increases productivity
   Reduces the development time

Why Spring Boot?
You can choose Spring Boot because of the features and benefits it offers as given here:
 It provides a flexible way to configure Java Beans, XML configurations, and Database Transactions.
 It provides a powerful batch processing and manages REST endpoints.
 In Spring Boot, everything is auto configured; no manual configurations are needed. 
 It offers annotation-based spring application
 Eases dependency management
 It includes Embedded Servlet Container

How does it work?
Spring Boot automatically configures your application based on the dependencies you have added to the project by using @EnableAutoConfiguration annotation.
The entry point of the Spring Boot Application is the class contains
@SpringBootApplication annotation. This class should have the main method to run the Spring Boot application. @SpringBootApplication annotation includes AutoConfiguration, Component Scan, and Spring Boot Configuration.
If you added @SpringBootApplication annotation to the class, you do not need to add the @EnableAutoConfiguration, @ComponentScan and @SpringBootConfiguration
annotation. The @SpringBootApplication annotation includes all other annotations.

Spring Boot Starters
Handling dependency management is a difficult task for big projects. Spring Boot resolves this problem by providing a set of dependencies for developers convenience.
For example, if you want to use Spring and JPA for database access, it is sufficient if you include spring-boot-starter-data-jpa dependency in your project.
Note that all Spring Boot starters follow the same naming pattern spring-boot-starter- *, where * indicates that it is a type of the application. 

Examples
Look at the following Spring Boot starters explained below for a better understanding:
Spring Boot Starter Actuator dependency is used to monitor and manage your application. Its code is shown below:

<dependency>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

SpringBoot Architecture:-

1.Controller Layer:
Handles incoming HTTP requests and sends responses. Acts as the entry point of the application.
It must not contain any business logic — only request handling and response mapping.
Commonly used annotations:
@Controller, @RestController, @RequestMapping, @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PathVariable, @RequestParam, @RequestBody, @Valid                     

2. DTO (Data Transfer Object):
Used to transfer data between layers (mainly between Controller and Service).
It helps hide internal entity structure and keeps the application secure and decoupled.
DTOs often carry validated request and response data.
Commonly used annotations:
@Data, @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor (from Lombok), @NotNull, @Email, @Size (for validation)

3. Service Layer (Interface):
Defines the business operations that the application supports.
Contains abstract methods for all major use cases.
This layer focuses on what actions to perform, not how to perform them.
Commonly used annotations:
No special annotations (usually defined as an interface).

4. Service Implementation Layer:
Implements the actual business logic declared in the Service interface.
Calls Repository/DAO to interact with the database.
This layer ensures that the Controller remains free of logic and Repository remains focused on persistence.
Commonly used annotations:
@Service, @Transactional, @Autowired

5. DAO (Data Access Object) Layer:
Defines the data persistence operations like save, update, delete, and fetch.
In traditional architecture, DAO interacts directly with JDBC or ORM frameworks like Hibernate.
In modern Spring Boot (with JPA), DAO is often replaced by Repository Layer.
Commonly used annotations:
@Repository


6. Exception Layer:
Handles all application-level exceptions in a centralized manner.
Prevents the app from crashing and returns meaningful error responses to the client.
Typically implemented using Global Exception Handling.
Commonly used annotations:
@ControllerAdvice, @RestControllerAdvice, @ExceptionHandler, @ResponseStatus

7. Repository Layer:
Responsible for interacting with the database using JPA, Hibernate, or MongoDB.
Contains predefined CRUD methods like save(), findById(), findAll(), deleteById() etc.
This layer is directly connected to Entity classes and Database.
Commonly used annotations:
@Repository, @Query, @Modifying
(Uses Spring Data interfaces like JpaRepository, CrudRepository, or MongoRepository)


8.Entity Layer (if used):
Represents database tables in the form of Java classes.
Each entity maps to a specific table with fields corresponding to columns.
Used by Repository layer to perform persistence operations.
Commonly used annotations:
@Entity, @Table, @Id, @GeneratedValue, @Column, @ManyToOne, @OneToMany, @JoinColumn

9.Configuration Layer (optional but common):
Contains application-level configurations like database, security, CORS, or messaging.
Helps manage Bean configurations and custom setups.
Commonly used annotations:
@Configuration, @Bean, @EnableWebSecurity, @EnableScheduling, @PropertySource





 


