Spring
Properties:
 ->Spring is the light weighted software which is directly depends on jdk
 ->Spring helps is build loosely coupled application
 ->It Requires less configuration and allows easy integration with any database
 ->It reduces boiler plate codes
 ->It supports IOC where objects are control by the program not by the programmer
 ->It supports dependency injections
 ->It provides default security 

IOC(Inversion Of Control)
 ->Ioc acts like a container in which the control of object creation is given to the program rather than the programmer with the help of 
   configuration file
 ->Ioc helps in creating object implicitly by reading configuration file and instantiate the pojo class

Types Ioc Context or Containers
1)Core Container
  ->We can create core container by using Interface BeanFactory  and XMLBeanFactory implementation class 
  ->We can build only standalone application

2)J2EE Container
  ->We can create this container by using ApplicationContext Interface and its implementation class are
            *ClassPathXmlApplicationContext
            *AnnotationConfigApplicationContext
  ->We can build enterprise level application

3)Web Container
  -> We can create web container by using WebApplicationContext  Interface And its Implementation class is WebApplicationContextUtil

Config.xml
 
Configuration file consists of a parent tag <beans></beans> and child tag is <bean></bean>
In order to configure a pojo class we make use of <bean> tag
<bean> takes two attributes id and class
In id we specify bean id for class we specify fully qualified class name.

Dependency Injection

Dependency Injection (DI) is a design pattern in which objects receive their dependencies from an external source rather than creating them manually by user.
It promotes loose coupling, easier testing, and better code maintainability. In Spring, DI is achieved mainly through Constructor Injection or Setter Injection.

xml data -> https://codeshare.io/5Qgj1e

<property>
    -> this tag will be used inside <bean> tag
    -> this use to set the value for the bean attributes/properties
    -> this tag contains 2 attributes name and value
    name- we need specify the attribute name(var name)
    value- this used specify value(should be encoded in " ")

ex:
<bean id="std" class="com.Student">
 <property name="age" value="28">  </property>
</bean>

class Student{
   
    int age;
    
    void setAge(int age){
       this.age=age;
    }
}

Note:For using property tag setter method for the attribute is must.
it follow proper naming convention

<constructor-arg>
    -> this tag is used inside bean tag when class is having
       parameterized constructor
    ->this tag has a attribute called value
    ->This tag should be used only if there is not at all default 
      construtor otherwise its not compulsory its depends business
      logic.

Ex-
  <bean>
   <constructor-arg value="virat"></constructor-arg>
   <constructor-arg value="28"></constructor-arg>
  </bean>
    
class student{
   
   String name;
   int age;

   Student(String name,int age){
   this.name=name;
   this.age=age;
  }
}

Annotation Based Spring Configuration

@Component:-

* Rather than creating bean tag for every pojo class in .xml configuration file 
  we make use @Component annotation.
* This is the class level annotation used on top of pojo class.
* It is used to make a class as qualified bean for the IOC.

Procedure to achieve annotation based bean creation and access it using .xml
and Application Context
->Create a pojo and annotate as @Component
->Go to .xml file and use <context:component-scan base-package="Package Path"/ > inside <Beans> tag
   Ex:<context:component-scan base-package="com.jspiders"/>
   Note:Make sure <beans> should contain xmlns:context attribute and value
  xml code ->  https://codeshare.io/5QkgDw
->In getBean() please do mention ClassName.class to access the object

@Scope ->Class based annotation
       ->It is used the scope of the class from singleton to prototype etc
      @Scope(value="prototype")

@Value ->It used to perform field injection .It is used inject the values.
         It can been used top of the attributes,Parameters,Setter Method

@Autowired :- It is used achieve automatic dependency injection.
              It will look into the context or container and finds the 
              matching bean and injects inside the field/attribute.
              It can be used with field/attribute ,constructor and setter.

@Primary :- It is class based annotation which describe the bean is having
            higher priority while autowiring .It will bean as default object 
            while autowiring.

@Qualifier :- It is used over come confusion /ambiguity issue when single 
              reference var has multiple objects at the time of autowiring.
              Using @qualifier we can specify the bean which can be autowired.
              @Qualifier can be used attribute/field level also and it 
              can used as class level annotation also.
             @Qualifier should be used along the side of @Autowired
            ex:-@Qualifier("QualifierName/ClassName(CamelCasing))
Note:-Qualifier name can be given for the bean with help @Component or @Qualifier
	
     @Component("QualifierName") 
     #@Qualifier("QualifierName")   
     class Demo{
     }

@Configuration: This annotation marks a class as a source of
bean definitions(creation).This can be used as a alternative
of .xml file.
Any class which is annotated as @Configuration will be treated
as configuration class it is equivalent to the .xml file
We can also use @Bean annotation inside configuration to create bean.

@ComponentScan:-
    This annotation is used along with @Configuration annotation
to search ,scan and create the bean.
Without @Component scan Spring or @Configuration cant search
and create bean automatically
 Syntax:-
      @ComponentScan(BasePackage="path")

MVC(Module View Controller):
   It is design pattern which is used to develop the loosely coupled application
   Model → represents the data & business logic
   View → represents the UI (presentation layer)
   Controller → acts as the request handler / coordinator

Spring MVC:
   It is spring framework which is used develop web application and distributed application.
Spring MVC is a request-driven web framework in the Spring ecosystem that implements the Model–View–Controller pattern on top of the Servlet API.

Spring Components :
->Front Controller(Dispatcher Servlet)
->Handler Mapper
->Controller
->ModelAndView
->ViewResolver
->View 

Front-Controller:-
   It is responsible for performing pre and post processing of incoming request
   Pre-processing :- Capturing the data from the request(ex:-form)
   Post-processing :-Sending response back to client in client understandable form.
  
   ->Spring web mvc application we will use dispatcherservlet as a front controller.
   DispatcherServlet(Spring framework servlet):-Predefine servlet class by spring

Handler Mapper:-
     It is predefine class in spring mvc.It is used to identify the request handler(Controller).The program which is handling the incoming request is called as request
handler.
handler Mapper will identify request handler and returns the details to dispatcher servlet

Controller:-
   It is a program which is used to handle the request.In Spring mvc user can create his own 
controller.In spring MNC some predefined controller classes are available like below
   ->SimpleFormController
   ->AbstractCommandController
   ->MultiActionController etc....
We can create userdefine controller by using @Controller annotation
Controller will return response the MAV or Understandable format 

ModelAndView:
  It is a predefine class in spring mvc.Where Model represent the data and view represent the logical view name.

ViewResolver:
   In spring mvc is multiple view resolver classes+
      ->InternalViewResourceViewResolver
      ->URLBasedViewResolver
      ->XmlViewResolver ...etc
  ->These view resolver are responsible to identify the views and send details(extension and 
    location)

View:
  It is used to render model data to view and returns it

Steps To Creat SpringMvc Project
->Create Maven project with maven-archetype webapp type
->Create configuration class
->create webintializer class with extends AbstractAnnotationConfigDispatcherServletIntilaizer  and override the methods .
->Use webapp for creating jsp pages

Model
An interface used to pass attributes (data) from the controller to
the view.
It acts as a container for the data to be rendered in the view 
(like JSP).
You typically use methods like addAttribute(String key, Object value)
to store data.

ModelMap
A map-based implementation of the Model interface.
It is very similar to Model but gives you direct access 
to the map-like structure(LinkedHashMap).
Useful if you want to add multiple attributes in a more flexible way.

ModelAndView
A holder for both the model and the view.
You can set both the view name and add data to the model
in a single object.
Useful when you want to return both the view and model explicitly.

@Controller:- Its Specialized form of @Component which will mark a 
class as webcontroller .That means this class will work as request
handler  of http request and returs the responses .

@RequestParam:- Its is used in SpringMvc which is used extract
 the data from url parameters,form data or request parameters and 
bind them with method arguements.
Note : Parameters and arguements names should be same

http://localhost:8080/SpringMvcProject/greet?name="Ankur"&&value="Priyanka"       

=================================================================================================================================================================
Monolithic Application
Definition:
A monolithic application is a single-tiered software application in which all the functionalities (UI, business logic, and database access) are packaged and deployed as one unit.

Advantages:
Simple to develop (suitable for beginners or small apps).
Easy to test and debug (everything in one place).
Simple deployment (only one package).
Shared database makes data handling straightforward.

Disadvantages:
Hard to scale (must scale the whole app, not parts).
Slower development for large projects (tight coupling).
Any small change requires redeployment of the entire application.
Failure in one module can bring down the whole system.

Micro Service Application:-
Micro Service is an architecture that allows the developers to develop and deploy services independently. Each service running has its own process and this achieves the lightweight model to support business applications.
Advantages
Micro services offers the following advantages to its developers:
   Easy deployment
   Simple scalability
   Compatible with Containers
   Minimum configuration
   Lesser production time 

What is Spring Boot?
Spring Boot provides a good platform for Java developers to develop a stand-alone and production-grade spring application that you can just run. You can get started with minimum configurations without the need for an entire Spring configuration setup.
Advantages
Spring Boot offers the following advantages to its developers:
   Easy to understand and develop spring applications
   Increases productivity
   Reduces the development time

Why Spring Boot?
You can choose Spring Boot because of the features and benefits it offers as given here:
 It provides a flexible way to configure Java Beans, XML configurations, and Database Transactions.
 It provides a powerful batch processing and manages REST endpoints.
 In Spring Boot, everything is auto configured; no manual configurations are needed. 
 It offers annotation-based spring application
 Eases dependency management
 It includes Embedded Servlet Container

How does it work?
Spring Boot automatically configures your application based on the dependencies you have added to the project by using @EnableAutoConfiguration annotation.
The entry point of the Spring Boot Application is the class contains
@SpringBootApplication annotation. This class should have the main method to run the Spring Boot application. @SpringBootApplication annotation includes AutoConfiguration, Component Scan, and Spring Boot Configuration.
If you added @SpringBootApplication annotation to the class, you do not need to add the @EnableAutoConfiguration, @ComponentScan and @SpringBootConfiguration
annotation. The @SpringBootApplication annotation includes all other annotations.

Spring Boot Starters
Handling dependency management is a difficult task for big projects. Spring Boot resolves this problem by providing a set of dependencies for developers convenience.
For example, if you want to use Spring and JPA for database access, it is sufficient if you include spring-boot-starter-data-jpa dependency in your project.
Note that all Spring Boot starters follow the same naming pattern spring-boot-starter- *, where * indicates that it is a type of the application. 

Examples
Look at the following Spring Boot starters explained below for a better understanding:
Spring Boot Starter Actuator dependency is used to monitor and manage your application. Its code is shown below:

<dependency>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

SpringBoot Architecture:-

1.Controller Layer:
Handles incoming HTTP requests and sends responses. Acts as the entry point of the application.
It must not contain any business logic — only request handling and response mapping.
Commonly used annotations:
@Controller, @RestController, @RequestMapping, @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PathVariable, @RequestParam, @RequestBody, @Valid                     

2. DTO (Data Transfer Object):
Used to transfer data between layers (mainly between Controller and Service).
It helps hide internal entity structure and keeps the application secure and decoupled.
DTOs often carry validated request and response data.
Commonly used annotations:
@Data, @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor (from Lombok), @NotNull, @Email, @Size (for validation)

3. Service Layer (Interface):
Defines the business operations that the application supports.
Contains abstract methods for all major use cases.
This layer focuses on what actions to perform, not how to perform them.
Commonly used annotations:
No special annotations (usually defined as an interface).

4. Service Implementation Layer:
Implements the actual business logic declared in the Service interface.
Calls Repository/DAO to interact with the database.
This layer ensures that the Controller remains free of logic and Repository remains focused on persistence.
Commonly used annotations:
@Service, @Transactional, @Autowired

5. DAO (Data Access Object) Layer:
Defines the data persistence operations like save, update, delete, and fetch.
In traditional architecture, DAO interacts directly with JDBC or ORM frameworks like Hibernate.
In modern Spring Boot (with JPA), DAO is often replaced by Repository Layer.
Commonly used annotations:
@Repository

6. Exception Layer:
Handles all application-level exceptions in a centralized manner.
Prevents the app from crashing and returns meaningful error responses to the client.
Typically implemented using Global Exception Handling.
Commonly used annotations:
@ControllerAdvice, @RestControllerAdvice, @ExceptionHandler, @ResponseStatus

7. Repository Layer:
Responsible for interacting with the database using JPA, Hibernate, or MongoDB.
Contains predefined CRUD methods like save(), findById(), findAll(), deleteById() etc.
This layer is directly connected to Entity classes and Database.
Commonly used annotations:
@Repository, @Query, @Modifying
(Uses Spring Data interfaces like JpaRepository, CrudRepository, or MongoRepository)

8.Entity Layer (if used):
Represents database tables in the form of Java classes.
Each entity maps to a specific table with fields corresponding to columns.
Used by Repository layer to perform persistence operations.
Commonly used annotations:
@Entity, @Table, @Id, @GeneratedValue, @Column, @ManyToOne, @OneToMany, @JoinColumn

9.Configuration Layer (optional but common):
Contains application-level configurations like database, security, CORS, or messaging.
Helps manage Bean configurations and custom setups.
Commonly used annotations:
@Configuration, @Bean, @EnableWebSecurity, @EnableScheduling, @PropertySource

Important Annotations And Definations 

@SpringBootApplication
Combines @Configuration, @EnableAutoConfiguration, and @ComponentScan.
It is the main entry point of any Spring Boot application.
Automatically sets up the Spring context, scans components, and configures beans.

Component Scanning and Stereotypes

@Component
Generic stereotype for any Spring-managed component (used when @Service, @Repository, or @Controller are not semantically appropriate).

@ComponentScan
Specifies base packages to scan for Spring components (@Component, @Service, @Controller, etc.).
Often used in configuration classes to control scanning scope.

Spring MVC (Web) Annotations

@Controller
This annotation marks a Java class as a Spring MVC controller. It is used to handle HTTP requests and return views (e.g., HTML pages). Typically used in applications with a frontend rendered by the server (e.g., Thymeleaf).

@RestController
A specialized version of @Controller that automatically serializes return objects to JSON or XML and includes @ResponseBody by default. It's used in RESTful web services.

@RequestMapping
Used to map web requests to specific handler methods in controller classes. It can be used at both the class level and method level. It supports all HTTP methods (GET, POST, PUT, DELETE) through its method attribute.

@GetMapping
A shorthand for @RequestMapping(method = RequestMethod.GET). It’s used to handle HTTP GET requests. Typically used for reading or retrieving data.

@PostMapping
A shorthand for @RequestMapping(method = RequestMethod.POST). Used to handle HTTP POST requests, often for creating new resources.

@PutMapping
A shortcut for handling HTTP PUT requests, which are generally used to update existing resources.

@DeleteMapping
Used to handle HTTP DELETE requests, typically used for deleting resources from the backend.

@PathVariable
Binds a variable from the URI path to a method parameter. For example, if your URL is /users/5, you can bind the 5 to a method parameter with @PathVariable("id") Long id.

@RequestParam
Used to extract query parameters from the URL. For example, /users?page=2&limit=5 can be mapped to method parameters using @RequestParam int page, @RequestParam int limit.

@RequestBody
Binds the body of a request (e.g., JSON or XML) to a method parameter. Often used in POST and PUT methods when the request body contains a full representation of a resource.

@Valid
Triggers validation on a method parameter, usually an object annotated with constraints like @NotNull, @Size, etc. This ensures incoming request data is valid.

Lombok Annotations

@Data
Generates boilerplate code such as getters, setters, toString(), equals(), hashCode(), and a constructor for final fields. It's a convenient shorthand for simple data carrier classes.

@Getter
Generates getter methods for all fields (if used on a class) or for a specific field (if used on a field).

@Setter
Generates setter methods, just like @Getter, but for setting field values.

@NoArgsConstructor
Generates a no-argument constructor. Useful especially when frameworks (like JPA) require a default constructor.

@AllArgsConstructor
Generates a constructor with one parameter for each field in the class.

@Builder
Implements the builder pattern to simplify the creation of objects with multiple parameters. It allows you to create objects like User.builder().name("John").age(25).build().

Validation Annotations (JSR-380 / Jakarta Bean Validation)

@NotNull
Ensures that the field is not null. Commonly used in DTOs (Data Transfer Objects) for request validation.

@Email
Ensures that the value is a valid email address format.

@Size
Validates the size of a collection, string, or array. For example, @Size(min=3, max=10) ensures a field has a length between 3 and 10.

Spring Service Layer and Dependency Injection

@Service
Marks a class as a service provider. It is used in the service layer of the application and is a specialization of @Component, allowing Spring to auto-detect it for dependency injection.

@Repository
Marks a class as a Data Access Object (DAO). It’s used to encapsulate database interaction logic. It also enables exception translation, converting database exceptions into Spring’s DataAccessException.

@Autowired
Tells Spring to automatically inject the dependency for a field, constructor, or method. It simplifies wiring beans into one another.

@Transactional
Used to indicate that a method or class should be executed within a transaction. This means all operations within the scope will either succeed together or fail together (rollback on error).

Spring Exception Handling

@ControllerAdvice
Defines a global exception handler for controllers annotated with @Controller. You can centralize exception handling logic here instead of writing it in each controller.

@RestControllerAdvice
Same as @ControllerAdvice, but specific to @RestController. It automatically applies @ResponseBody so that exceptions return JSON or XML responses.

@ExceptionHandler
Used inside @ControllerAdvice or controllers to specify a method that handles a specific exception type.

@ResponseStatus
Allows you to define the HTTP status code returned by a controller method or exception handler method. For example, @ResponseStatus(HttpStatus.NOT_FOUND).

Spring Data JPA (Persistence Layer)

@Entity
Marks a class as a JPA entity, meaning it maps to a database table. Must be used with @Id to define the primary key.

@Table
Optional annotation used to specify the name of the table that this entity maps to. If not used, the table name is usually inferred from the class name.

@Id
Defines the primary key of the entity. Required for any class annotated with @Entity.

@GeneratedValue
Specifies how the primary key is generated (e.g., AUTO, IDENTITY, SEQUENCE). Works with @Id.

@Column
Used to map a field to a specific column in the database. You can customize the column name, length, nullability, etc.

@ManyToOne
Defines a many-to-one relationship between two entities. For example, many orders can belong to one customer.

@OneToMany
Defines a one-to-many relationship. For example, one customer may have many orders. Typically used with mappedBy to avoid circular dependency.

@JoinColumn
Specifies the foreign key column for an entity relationship. Used with @ManyToOne or @OneToOne to map the join column in the database.

@Query
Used to define custom queries in Spring Data JPA repositories. You can write JPQL or native SQL queries here.

@Modifying
Used with @Query to indicate that the query performs a write operation (e.g., UPDATE, DELETE). It is required when executing non-select operations.

Spring Configuration & Bean Management

@Configuration
Marks a class as a source of Spring bean definitions. It’s often used instead of XML for Java-based configuration.

@Bean
Indicates that a method returns a Spring-managed bean. Used inside a class annotated with @Configuration.

@EnableWebSecurity
Enables Spring Security’s web security features. You use this in a configuration class to define custom security rules.

@EnableScheduling
Enables Spring’s task scheduling support, allowing methods annotated with @Scheduled to run periodically or at fixed intervals.

@PropertySource
Specifies the location of a properties file to be loaded into the Spring Environment. For example, it can be used to load application-specific configurations.





 


